<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>Maiden</title> <meta name="viewport" content="width=device-width"/> <meta name="description" content="A modern and extensible chat bot framework."/> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"/> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }
      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
          text-align: center;
      }
      body>header img{
          max-width: 50%;
      }
      img{
          max-width: 100%;
          max-height: 100%;
      }
      code{
          font-family: Consolas, Inconsolata, monospace;
      }
      a{
          text-decoration: none;
          color: #0055AA;
      }
      a img{
          border: none;
      }
      #documentation{
          text-align: justify;
      }
      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }
      #documentation img{
          margin: 5px;
      }
      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }
      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1><img alt="maiden" src="maiden-logo.svg"/></h1> <span class="version">3.0.0</span> <p class="description">A modern and extensible chat bot framework.</p> </header> <main> <article id="documentation">  <div><h2>About Maiden</h2> <p>Maiden is a collection of systems to help you build applications and libraries that interact with chat servers. It can help you build a chat bot, or a general chat client. It also offers a variety of parts that should make it much easier to write a client for a new chat protocol.</p> <h2>How To Use Maiden as a Bot</h2> <p>If you only care about using Maiden to set up a bot of some kind, the steps to do so are rather straightforward. First we'll want to load in Maiden and all of the modules and components that you'd like to use in your bot.</p> <pre><code>(ql:quickload '(maiden maiden-irc maiden-command maiden-silly))</code></pre> <p>And then we'll create a core with instances of the consumers added to it as we'd like them to be.</p> <pre><code>(<a href="http://l1sp.org/cl/defvar">defvar</a> *core* (<a href="#MAIDEN:MAKE-CORE">maiden:make-core</a>
                 '(:maiden-irc :nickname &quot;MaidenTest&quot; :host &quot;irc.freenode.net&quot; :channels (&quot;##testing&quot;))
                 :maiden-command
                 :maiden-silly))</code></pre> <p>The make-core command takes either package names (as strings or symbols) of consumers to add, or the direct class name of a consumer. In the former case it'll try to find the appropriate consumer class name on its own.</p> <p>And that's it. <code><a href="#MAIDEN:MAKE-CORE">make-core</a></code> will create a core, instantiate all the consumers, add them to it, and start everything up. A loot of the modules provided for Maiden will make use of some kind of configuration or persistent storage. For the management thereof, see the <a href="modules/storage/">storage</a> subsystem.</p> <h2>How To Use Maiden as a Framework to Develop With</h2> <p>In order to use Maiden as a framework, you'll first want to define your own system and package as usual for a project. For now we'll just use the <code>maiden-user</code> package to play around in. Next we'll want to define a consumer. This can be done with <code><a href="#MAIDEN:DEFINE-CONSUMER">define-consumer</a></code>.</p> <pre><code>(<a href="http://l1sp.org/cl/in-package">in-package</a> #:maiden-user)
(<a href="#MAIDEN:DEFINE-CONSUMER">define-consumer</a> ping-notifier (<a href="#MAIDEN:AGENT">agent</a>)
  ())</code></pre> <p>Usually you'll want to define an agent. Agents can only exist once on a core. We'll go through an example for a client later. Now, from here on out we can define our own methods and functions that specialise or act on the consumer class as you'd be used to from general CLOS programming. Next, we'll define our own event that we'll use to send &quot;ping requests&quot; to the system.</p> <pre><code>(<a href="#MAIDEN:DEFINE-EVENT">define-event</a> ping (<a href="#MAIDEN:PASSIVE-EVENT">passive-event</a>)
  ())</code></pre> <p>The event is defined as a <code><a href="#MAIDEN:PASSIVE-EVENT">passive-event</a></code> as it is not directly requesting an action to be taken, but rather informs the system of a ping that's happening. Now, in order to actually make the consumer interact with the event system however, we'll also want to define handlers. This can be done with <code><a href="#MAIDEN:DEFINE-HANDLER">define-handler</a></code>.</p> <pre><code>(<a href="#MAIDEN:DEFINE-HANDLER">define-handler</a> (ping-notifier ping-receiver ping) (c ev)
  (v:info :ping &quot;Received a ping: ~a&quot; ev))</code></pre> <p>This defines a handler called <code>ping-receiver</code> on our <code>ping-notifier</code> consumer. It also specifies that it will listen for events of type <code>ping</code>. The arglist afterwards says that the consumer instance is bound to <code>c</code> and the event instance to <code>ev</code>. The body then simply logs an informational message using <a href="https://shinmera.github.io/verbose">Verbose</a>.</p> <p>Let's test this out real quick.</p> <pre><code>(<a href="http://l1sp.org/cl/defvar">defvar</a> *core* (<a href="#MAIDEN:MAKE-CORE">make-core</a> 'ping-notifier))

(<a href="#MAIDEN:DO-ISSUE">do-issue</a> *core* ping)</code></pre> <p>That should print the status message to the REPL as expected. And that's most of everything there is to using this system. Note that in order to do actually useful things, you'll probably want to make use of some of the preexisting subsystems that the Maiden project delivers aside from the core. Those will help you with users, channels, accounts, commands, networking, storage, and so forth. Also keep in mind that you can make use of the features that <a href="https://shinmera.github.io/deeds">Deeds</a> offers on its own as well, such as filtering expressions for handlers.</p> <p>Now let's take a look at a primitive kind of client. The client will simply be able to write to a file through events.</p> <pre><code>(<a href="#MAIDEN:DEFINE-CONSUMER">define-consumer</a> file-client (<a href="#MAIDEN:CLIENT">client</a>)
  ((file :initarg :file :accessor file))
  (:default-initargs :file (<a href="http://l1sp.org/cl/error">error</a> &quot;FILE required.&quot;)))
  
(<a href="#MAIDEN:DEFINE-EVENT">define-event</a> write-event (<a href="#MAIDEN:CLIENT-EVENT">client-event</a> active-event)
  ((sequence :initarg :sequence))
  (:default-initargs :sequence (<a href="http://l1sp.org/cl/error">error</a> &quot;SEQUENCE required.&quot;)))</code></pre> <p>We've made the <code>write-event</code> a <code><a href="#MAIDEN:CLIENT-EVENT">client-event</a></code> since it needs to be specific to a client we want to write to, and we've made it an <code><a href="#MAIDEN:ACTIVE-EVENT">active-event</a></code> since it requests something to happen. Now let's define our handler that will take care of actually writing the sequence to file.</p> <pre><code>(<a href="#MAIDEN:DEFINE-HANDLER">define-handler</a> (file-client writer write-event) (c ev sequence)
  :match-consumer 'client
  (<a href="http://l1sp.org/cl/with-open-file">with-open-file</a> (<a href="http://l1sp.org/cl/stream">stream</a> (file c) :direction :output :if-exists :append :if-does-not-exist :create)
    (<a href="http://l1sp.org/cl/write-sequence">write-sequence</a> sequence stream)))</code></pre> <p>The <code>:match-consumer</code> option modifies the handler's filter in such a way that the filter will only pass events whose <code><a href="#MAIDEN:CLIENT">client</a></code> slot contains the same <code>file-client</code> instance as the current handler instance belongs to. This is important, as each instance of <code>file-client</code> will receive its own instances of its handlers on a core. Without this option, the <code>write-event</code> would be handled by every instance of the <code>file-client</code> regardless of which instance the event was intended for. Also note that we added a <code><a href="http://l1sp.org/cl/sequence">sequence</a></code> argument to the handler's arglist. This argument will be filled with the appropriate slot from the event. If no such slot could be found, an error is signalled.</p> <p>Time to test it out. We'll just reuse the core from above.</p> <pre><code>(<a href="#MAIDEN:ADD-TO-CORE">add-to-core</a> *core* '(file-client :file &quot;~/foo&quot; :name :foo)
                    '(file-client :file &quot;~/bar&quot; :name :bar))

(<a href="#MAIDEN:DO-ISSUE">do-issue</a> *core* write-event :sequence &quot;foo&quot; :client (<a href="#MAIDEN:CONSUMER">consumer</a> :foo *core*))
(<a href="#MAIDEN:DO-ISSUE">do-issue</a> *core* write-event :sequence &quot;bar&quot; :client (<a href="#MAIDEN:CONSUMER">consumer</a> :bar *core*))

(alexandria:read-file-into-string &quot;~/foo&quot;) ; =&gt; &quot;foo&quot;
(alexandria:read-file-into-string &quot;~/bar&quot;) ; =&gt; &quot;bar&quot;</code></pre> <p>As you can see, the events were directed to the appropriate handler instances according to the client we wanted, and the files thus contain what we expect them to.</p> <p>Finally, it is worth mentioning that it is also possible to dynamically add and remove handlers at runtime, and even do so for handlers that are not associated with a particular consumer. This is often useful when you need to wait for a response event from somewhere. To handle the logic of doing this asynchronously and retain the impression of an imperative flow, Maiden offers --just as Deeds does-- a <code><a href="#MAIDEN:WITH-AWAITING">with-awaiting</a></code> macro. It can be used as follows:</p> <pre><code>(<a href="#MAIDEN:WITH-AWAITING">with-awaiting</a> (<a href="#MAIDEN:CORE">core</a> event-type) (ev some-field)
    (<a href="#MAIDEN:DO-ISSUE">do-issue</a> core initiating-event)
  :timeout 20
  some-field)</code></pre> <p><code><a href="#MAIDEN:WITH-AWAITING">with-awaiting</a></code> is very similar to <code><a href="#MAIDEN:DEFINE-HANDLER">define-handler</a></code>, with the exception that it doesn't take a name, and instead of a consumer name at the beginning it needs a core or consumer instance. It also takes one extra option that is otherwise unused, the <code>:timeout</code>. Another required extra is the &quot;setup form&quot; after the arglist. In order to properly manage everything and ensure no race conditions may occur in the system, you must initiate the process that will prompt the eventual response event in this setup form. If you initiate it before then, the response event might be sent out before the temporary handler is set up in the system and it'll appear as if it never arrived at all.</p> <p>And that's pretty much all of the basics. As mentioned above, take a look at the subsystems this project includes, as they will help you with all sorts of common tasks and problems revolving around chat systems and so on.</p> <h2>Core Documentation</h2> <p>Before understanding Maiden, it is worth it to understand <a href="https://shinmera.github.io/deeds">Deeds</a>, if only at a surface level. Maiden builds on it rather heavily.</p> <h3>Core</h3> <p>A <code><a href="#MAIDEN:CORE">core</a></code> is the central part of a Maiden configuration. It is responsible for managing and orchestrating the other components of the system. You can have multiple cores running simultaneously within the same lisp image, and can even share components between them.</p> <p>More specifically, a Core is made up of an event-loop and a set of consumers. The event-loop is responsible for delivering events to handlers. Consumers are responsible for attaching handlers to the event-loop. The operations you will most likely want to perform on a core are thus: issuing events to it by <code><a href="#MAIDEN:ISSUE">issue</a></code>, adding consumers to it by <code><a href="#MAIDEN:ADD-CONSUMER">add-consumer</a></code>, or removing a consumer from it by <code><a href="#MAIDEN:REMOVE-CONSUMER">remove-consumer</a></code>.</p> <p>In order to make it easier on your to create a useful core with consumers added to it, you can make use of the <code><a href="#MAIDEN:MAKE-CORE">make-core</a></code> and <code><a href="#MAIDEN:ADD-TO-CORE">add-to-core</a></code> functions.</p> <h3>Event</h3> <p>An <code><a href="#MAIDEN:EVENT">event</a></code> is an object that represents a change in the system. Events can be used to either represent a change that has occurred, or to represents a request for a change to happen. These are called <code><a href="#MAIDEN:PASSIVE-EVENT">passive-event</a></code>s and <code><a href="#MAIDEN:ACTIVE-EVENT">active-event</a></code>s respectively.</p> <p>Generally you will use events in the following ways:</p> <ol> <li>Consuming them by writing a handler that takes events of a particular type and does something in response to them.</li> <li>Define new event classes that describe certain behaviour.</li> <li>Emitting them by writing components that inform the system about changes.</li> </ol> <h3>Consumer</h3> <p>A <code><a href="#MAIDEN:CONSUMER">consumer</a></code> is a class that represents a component in the system. Each consumer can have a multitude of handlers tied to it, which will react to events in the system. Consumers come in two basic supertypes, <code><a href="#MAIDEN:AGENT">agent</a></code>s and <code><a href="#MAIDEN:CLIENT">client</a></code>s. Agents are consumers that should only exist on a core once, as they implement functionality that would not make sense to be multiplexed in some way. Clients on the other hand represent some kind of bridge to an outside system, and naturally should be allowed to have multiple instances on the same core.</p> <p>Thus developing a set of commands or an interface of some kind would probably lead to an agent, whereas interfacing with a service like XMPP would lead to a client.</p> <p>Defining a consumer should happen with <code><a href="#MAIDEN:DEFINE-CONSUMER">define-consumer</a></code>, which is similar to the standard <code><a href="http://l1sp.org/cl/defclass">defclass</a></code>, but ensures that the superclasses and metaclasses are properly set up.</p> <h3>Handler</h3> <p><code>handler</code>s are objects that hold a function that performs certain actions when a particular event is issued onto the core. Each handler is tied to a particular consumer and is removed or added to the core's event-loop when the consumer is removed or added to the core.</p> <p>Handler definition happens through one of <code><a href="#MAIDEN:DEFINE-HANDLER">define-handler</a></code>, <code><a href="#MAIDEN:DEFINE-FUNCTION-HANDLER">define-function-handler</a></code>, <code><a href="#MAIDEN:DEFINE-INSTRUCTION">define-instruction</a></code>, or <code><a href="#MAIDEN:DEFINE-QUERY">define-query</a></code>. Which each successively build on the last to provide a broader shorthand for common requirements. Note that the way in which a handler actually receives its events can differ. Have a look at the Deeds' documentation to see what handler classes are available.</p> <h2>Subsystems</h2> <p>Included in the Maiden project are a couple of subsystems that extend the core functionality.</p> <ul> <li><a href="modules/api-access/">API Access</a> -- Helper functions to access remote APIs over HTTP.</li> <li><a href="modules/client-entities/">Client Entities</a> -- Common entities for clients and remote systems.</li> <li><a href="modules/networking/">Networking</a> -- Client mixins to handle network connections.</li> <li><a href="modules/serialize/">Serialize</a> -- Data to wire serialization.</li> <li><a href="modules/storage/">Storage</a> -- Configuration and data storage.</li> </ul> <h2>Existing Clients</h2> <p>The Maiden project also includes a few standard clients that can be used right away.</p> <ul> <li><a href="clients/irc/">IRC</a> -- <a href="https://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat</a> client.</li> <li><a href="clients/lichat/">Lichat</a> -- <a href="https://shirakumo.github.io/lichat">Lichat</a> client.</li> <li><a href="clients/relay/">Relay</a> -- Maiden relay. Allows connecting remote Maiden cores.</li> </ul> <h2>Existing Agents</h2> <p>Finally, the project has a bunch of agent modules that provide functionality that is useful for creating chat bots and such. They, too, can be used straight away.</p> <ul> <li><a href="agents/accounts/">accounts</a> -- User accounts.</li> <li><a href="agents/activatable/">activatable</a> -- Allow activating or deactivating consumer's handlers.</li> <li><a href="agents/blocker/">blocker</a> -- Block commands by rules.</li> <li><a href="agents/chatlog/">chatlog</a> -- Log channels to a database.</li> <li><a href="agents/commands/">commands</a> -- Provide a common command infrastructure.</li> <li><a href="agents/core-manager/">core-manager</a> -- Manage the core's consumers and parts.</li> <li><a href="agents/counter/">counter</a> -- Count occurrences in message events.</li> <li><a href="agents/crimes/">crimes</a> -- Lets the user play &quot;Crimes&quot;, a Cards Against Humanity clone.</li> <li><a href="agents/emoticon/">emoticon</a> -- Provides :emote:s in messages.</li> <li><a href="agents/help/">help</a> -- A generic command help system.</li> <li><a href="agents/location/">location</a> -- Allows retrieving location information.</li> <li><a href="agents/markov/">markov</a> -- Provides efficient markov chains.</li> <li><a href="agents/medals/">medals</a> -- Gives commands to hand out &quot;medals&quot; to users.</li> <li><a href="agents/notify/">notify</a> -- Allow sending users notification messages.</li> <li><a href="agents/permissions/">permissions</a> -- Manage command permissions.</li> <li><a href="agents/quicklisp/">quicklisp</a> -- Operate Quicklisp and system updates through commands.</li> <li><a href="agents/silly/">silly</a> -- Adds some silly commands and automatic message responses.</li> <li><a href="agents/talk/">talk</a> -- Allows playing Text To Speech messages on the machine Maiden runs on.</li> <li><a href="agents/throttle/">throttle</a> -- Throttle users to prevent them from issuing too many commands.</li> <li><a href="agents/time/">time</a> -- Provides time information.</li> <li><a href="agents/trivia/">trivia</a> -- Implements a simple trivia game.</li> <li><a href="agents/urlinfo/">urlinfo</a> -- Retrieves information about URLs.</li> <li><a href="agents/weather/">weather</a> -- Provides weather and forecast information for a location.</li> </ul> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>maiden</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  Â© <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .  This library can be obtained on <a href="https://github.com/Shinmera/maiden">https://github.com/Shinmera/maiden</a>.  </article>  <article id="symbol-index"> <h2>Package Index</h2> <ul><li class="package"> <h3> <a name="MAIDEN" href="#MAIDEN">MAIDEN</a> <span class="nicknames">(ORG.SHIRAKUMO.MAIDEN)</span> </h3> <ul><li> <a name="MAIDEN:*DEBUGGER*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#MAIDEN:*DEBUGGER*">*DEBUGGER*</a></code></h4>  </header> <div class="docstring"><pre>This variable sets whether an internal error should call out to the debugger or not.

On deployed systems, this should probably be NIL. The
default value is whether the SWANK package is present
or not.</pre></div> </article> </li><li> <a name="MAIDEN:*ROOT*"> </a> <article> <header class="special"> <span class="type">special</span>  <h4 class="name"><code><a href="#MAIDEN:*ROOT*">*ROOT*</a></code></h4>  </header> <div class="docstring"><pre>This variable holds a directory pathname that points to the &quot;root&quot; of the Maiden installation.

The root should mainly be used for storage of runtime
fragments such as configuration, cache, and so forth.</pre></div> </article> </li><li> <a name="MAIDEN:ABSTRACT-HANDLER"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a></code></h4>  </header> <div class="docstring"><pre>This is an object to represent a handler definition. It contains all data necessary to construct an appropriate handler instance for a consumer.

See <a href="#MAIDEN:TARGET-CLASS">TARGET-CLASS</a>
See <a href="#MAIDEN:OPTIONS">OPTIONS</a>
See <a href="#MAIDEN:INSTANTIATE-HANDLER">INSTANTIATE-HANDLER</a>
See <a href="#MAIDEN:DEFINE-HANDLER">DEFINE-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:ACTIVE-EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:ACTIVE-EVENT">ACTIVE-EVENT</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all active events in the system.

An active event notifies of a request for an action to be
taken somewhere in the system. It is active in the sense that
it should cause some part of the system to perform an action,
rather than merely notifying of a change happening.

See <a href="#MAIDEN:EVENT">EVENT</a>
See <a href="#MAIDEN:PASSIVE-EVENT">PASSIVE-EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:AGENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:AGENT">AGENT</a></code></h4>  </header> <div class="docstring"><pre>A type of consumer of which only one instance should exist on a core.

An agent's name defaults to the agent's class name.

An agent MATCHES if the class or the class name matches.

If an agent is attempted to be added to a core when an
agent that matches it by name already exists on the core,
a warning of type AGENT-ALREADY-EXISTS-ERROR is signalled.

See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:BLOCK-LOOP"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:BLOCK-LOOP">BLOCK-LOOP</a></code></h4>  </header> <div class="docstring"><pre>Base class for the block loop on a Maiden core.

See <a href="#MAIDEN:CORE">CORE</a>
See <a href="NIL">DEEDS:EVENT-LOOP</a></pre></div> </article> </li><li> <a name="MAIDEN:CLIENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CLIENT">CLIENT</a></code></h4>  </header> <div class="docstring"><pre>A type of consumer of which multiple instances can exist on a core.

See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:CLIENT-EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CLIENT-EVENT">CLIENT-EVENT</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all events that relate to a client.

This event holds the client it relates to in a slot.

See <a href="#MAIDEN:CLIENT">CLIENT</a>
See <a href="#MAIDEN:EVENT">EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:CONSUMER"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CONSUMER">CONSUMER</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all consumers on a core.

Consumers are responsible for issuing and responding to
events that happen on a core. They do this by having a number
of handler definitions tied to them, which are instantiated
into proper handlers when they are added to a core. These
handlers are then added to the core's event-loop in order to
react to events. See the Deeds library for information on how
the event-loop and handlers work in detail.

Consumers are divided into two classes, ones of which only a
single instance should exist on the core, and ones of which
many may exist on the core. The former are called AGENTS, and
the latter are called CLIENTS. The former usually provide
functionality that is reactionary in some sense. The latter
usually provide some form of connection to another entity and
primarily provide events rather than consuming them. You should
not inherit directly from CONSUMER therefore, and rather pick
either CLIENT or AGENT, depending on which of the two is more
suitable for the kind of consumer you want to write for the
system.

Consumer classes must inherit from the CONSUMER-CLASS class,
which is responsible for ensuring that handler definitions get
properly instantiated and managed over consumer instances.

In order to easily define consumer classes with the appropriate
superclass and metaclass, you can use DEFINE-CONSUMER.

In order to add handlers to the consumer, use DEFINE-HANDLER.

Each consumer has a LOCK that can be used to synchronise
access to the consumer from different parts in the system.
Since Deeds, and Maiden by extension, is highly parallel most
of the time, locking of resources and access to the consumer
from different handlers is vital.

The list of handler instances is held in the HANDLERS slot.
The list of cores the consumer is on is held in the CORES slot.

You can start and stop all the handlers on a consumer by the
usual Deeds START and STOP functions.

After the initialisation of a consumer, the consumer instance
is pushed onto the INSTANCES list of its class by way of a
weak-pointer. It will also turn all of its effective-handlers
into actual handler instances by way of INSTANTIATE-HANDLER and
push them onto its HANDLERS list.

See <a href="#MAIDEN:NAMED-ENTITY">NAMED-ENTITY</a>
See <a href="#MAIDEN:CONSUMER-CLASS">CONSUMER-CLASS</a>
See <a href="#MAIDEN:AGENT">AGENT</a>
See <a href="#MAIDEN:CLIENT">CLIENT</a>
See <a href="#MAIDEN:DEFINE-CONSUMER">DEFINE-CONSUMER</a>
See <a href="#MAIDEN:DEFINE-HANDLER">DEFINE-HANDLER</a>
See <a href="#MAIDEN:HANDLERS">HANDLERS</a>
See <a href="#MAIDEN:CORES">CORES</a>
See <a href="#MAIDEN:LOCK">LOCK</a>
See <a href="#MAIDEN:START">START</a>
See <a href="#MAIDEN:STOP">STOP</a>
See <a href="#MAIDEN:INSTANCES">INSTANCES</a>
See <a href="#MAIDEN:INSTANTIATE-HANDLER">INSTANTIATE-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:CONSUMER-ADDED"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CONSUMER-ADDED">CONSUMER-ADDED</a></code></h4>  </header> <div class="docstring"><pre>Event that is issued after a consumer has been added to the core.

See <a href="#MAIDEN:CORE-EVENT">CORE-EVENT</a>
See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:CONSUMER-CLASS"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CONSUMER-CLASS">CONSUMER-CLASS</a></code></h4>  </header> <div class="docstring"><pre>Metaclass for all consumer objects.

It handles the proper instantiation of handler objects when the
consumer is added to a core or the handler definitions are
updated.

See <a href="#MAIDEN:DIRECT-HANDLERS">DIRECT-HANDLERS</a>
See <a href="#MAIDEN:EFFECTIVE-HANDLERS">EFFECTIVE-HANDLERS</a>
See <a href="#MAIDEN:INSTANCES">INSTANCES</a>
See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:CONSUMER-REMOVED"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CONSUMER-REMOVED">CONSUMER-REMOVED</a></code></h4>  </header> <div class="docstring"><pre>Event that is issued after a consumer has been removed from the core.

See <a href="#MAIDEN:CORE-EVENT">CORE-EVENT</a>
See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:CORE"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CORE">CORE</a></code></h4>  </header> <div class="docstring"><pre>The core of an event system in Maiden.

The core is responsible for managing events, consumers, and
their handlers. It uses two (!) event-loops in the back to
handle event delivery. The first loop, called the primary
loop is where most handlers live. It is (by default) of type
PRIMARY-LOOP and should be fairly speed in delivery, at
the cost that adding and removing handlers will be slow. The
second loop, called the blocking loop is where temporary
handlers that only exist for hopefully a short time live. It
is (by default) of type BLOCK-LOOP and is not optimised
for fast delivery, but much faster at removing and adding
handlers. Thus, whenever you wait for an event for a one-time
request, the handler should be added to the block loop.

Calling DE/REGISTER-HANDLER on a core will automatically add
it to the primary loop. If you want to change the blocking
loop you will have to access it directly.

When an event is ISSUEd onto the core, it is ISSUEd onto the
primary loop and then ISSUEd onto the block loop. The
behaviour for when an event is directly HANDLEd by the core
is analogous.

See <a href="#MAIDEN:PRIMARY-LOOP">PRIMARY-LOOP</a>
See <a href="#MAIDEN:BLOCK-LOOP">BLOCK-LOOP</a>
See <a href="#MAIDEN:CONSUMERS">CONSUMERS</a>
See <a href="#MAIDEN:CONSUMER">CONSUMER</a>
See <a href="#MAIDEN:ADD-CONSUMER">ADD-CONSUMER</a>
See <a href="#MAIDEN:REMOVE-CONSUMER">REMOVE-CONSUMER</a>
See <a href="#MAIDEN:START">START</a>
See <a href="#MAIDEN:STOP">STOP</a>
See <a href="#MAIDEN:ISSUE">ISSUE</a>
See <a href="NIL">HANDLE</a>
See <a href="#MAIDEN:WITH-AWAITING">WITH-AWAITING</a>
See <a href="NIL">WITH-RESPONSE</a>
See <a href="#MAIDEN:MAKE-CORE">MAKE-CORE</a>
See <a href="#MAIDEN:ADD-TO-CORE">ADD-TO-CORE</a></pre></div> </article> </li><li> <a name="MAIDEN:CORE-EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:CORE-EVENT">CORE-EVENT</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all events relating to a Maiden core.

See <a href="#MAIDEN:EVENT">EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:DATA-ENTITY"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:DATA-ENTITY">DATA-ENTITY</a></code></h4>  </header> <div class="docstring"><pre>Superclass for entities that have a data storage table.

See <a href="#MAIDEN:ENTITY">ENTITY</a>
See <a href="#MAIDEN:DATA">DATA</a>
See <a href="#MAIDEN:DATA-VALUE">DATA-VALUE</a></pre></div> </article> </li><li> <a name="MAIDEN:ENTITY"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:ENTITY">ENTITY</a></code></h4>  </header> <div class="docstring"><pre>Superclass for things that are comparable according to some kind of identity.

See <a href="#MAIDEN:ID">ID</a></pre></div> </article> </li><li> <a name="MAIDEN:EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:EVENT">EVENT</a></code></h4>  </header> <div class="docstring"><pre>The superclass for all events in Maiden.

An event is an object that represents a change that occurs
in the system. It may also carry relevant information about
the change. Events can also be used to signify requests for
things to happen in the system.

Events need to be ISSUEd onto a core, where they will then
be dispatched to HANDLERs that can process it.

See <a href="NIL">EVENT-CLASS</a>
See <a href="#MAIDEN:CORE">CORE</a>
See <a href="#MAIDEN:EVENT">DEEDS:EVENT</a>
See <a href="#MAIDEN:DEFINE-EVENT">DEFINE-EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:INSTRUCTION-EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:INSTRUCTION-EVENT">INSTRUCTION-EVENT</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all instruction events in the system.

Instructions are event representations of a change request in
the system. They often represent a &quot;virtual&quot; function call.

See <a href="#MAIDEN:DEFINE-INSTRUCTION">DEFINE-INSTRUCTION</a>
See <a href="#MAIDEN:ACTIVE-EVENT">ACTIVE-EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:NAMED-ENTITY"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:NAMED-ENTITY">NAMED-ENTITY</a></code></h4>  </header> <div class="docstring"><pre>An entity with a human-readable name attached to it.

See <a href="#MAIDEN:ENTITY">ENTITY</a>
See <a href="#MAIDEN:NAME">NAME</a></pre></div> </article> </li><li> <a name="MAIDEN:PASSIVE-EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:PASSIVE-EVENT">PASSIVE-EVENT</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all passive events in the system.

A passive event notifies of a change that happened somewhere
in the system. It is passive in the sense that it provides
information, rather than explicitly requesting information or
explicitly requesting an action.

See <a href="#MAIDEN:EVENT">EVENT</a>
See <a href="#MAIDEN:ACTIVE-EVENT">ACTIVE-EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:PRIMARY-LOOP"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:PRIMARY-LOOP">PRIMARY-LOOP</a></code></h4>  </header> <div class="docstring"><pre>Base class for the primary loop on a Maiden core.

See <a href="#MAIDEN:CORE">CORE</a>
See <a href="NIL">DEEDS:COMPILED-EVENT-LOOP</a></pre></div> </article> </li><li> <a name="MAIDEN:QUERY-EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:QUERY-EVENT">QUERY-EVENT</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all query events in the system.

Queries are events that represent both a change request and
a request for a result to be obtained about the change. They
often represent a &quot;full&quot; function call.

It is identified so that it and its response event counter-
piece can be found.

See <a href="#MAIDEN:DEFINE-QUERY">DEFINE-QUERY</a>
See <a href="NIL">DEEDS:IDENTIFIED-EVENT</a>
See <a href="#MAIDEN:INSTRUCTION-EVENT">INSTRUCTION-EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:RESPONSE-EVENT"> </a> <article> <header class="class"> <span class="type">class</span>  <h4 class="name"><code><a href="#MAIDEN:RESPONSE-EVENT">RESPONSE-EVENT</a></code></h4>  </header> <div class="docstring"><pre>Generic response event class.

This event is used to deliver the response payload of a
query-event. Its IDentity must be the same as that of the
query-event that prompted it.

See <a href="NIL">DEEDS:IDENTIFIED-EVENT</a>
See <a href="NIL">DEEDS:PAYLOAD-EVENT</a>
See <a href="#MAIDEN:PASSIVE-EVENT">PASSIVE-EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:AGENT-ALREADY-EXISTS-ERROR"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MAIDEN:AGENT-ALREADY-EXISTS-ERROR">AGENT-ALREADY-EXISTS-ERROR</a></code></h4>  </header> <div class="docstring"><pre>A condition signalled when an agent of the same name already exists on the core.

See <a href="#MAIDEN:EXISTING-AGENT">EXISTING-AGENT</a>
See <a href="#MAIDEN:AGENT-CONDITION">AGENT-CONDITION</a>
See <a href="#MAIDEN:CORE-CONDITION">CORE-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:AGENT-CONDITION"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MAIDEN:AGENT-CONDITION">AGENT-CONDITION</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all conditions related to agents.

See <a href="#MAIDEN:AGENT">AGENT</a>
See <a href="#MAIDEN:MAIDEN-CONDITION">MAIDEN-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:CLIENT-CONDITION"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MAIDEN:CLIENT-CONDITION">CLIENT-CONDITION</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all conditions related to clients.

See <a href="#MAIDEN:CLIENT">CLIENT</a>
See <a href="#MAIDEN:MAIDEN-CONDITION">MAIDEN-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:CONSUMER-NAME-DUPLICATED-WARNING"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MAIDEN:CONSUMER-NAME-DUPLICATED-WARNING">CONSUMER-NAME-DUPLICATED-WARNING</a></code></h4>  </header> <div class="docstring"><pre>A condition signalled when a consumer is added to a core and has the same name as an already existing consumer.

See <a href="#MAIDEN:EXISTING-CONSUMER">EXISTING-CONSUMER</a>
See <a href="#MAIDEN:NEW-CONSUMER">NEW-CONSUMER</a>
See <a href="#MAIDEN:CORE-CONDITION">CORE-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:CORE-CONDITION"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MAIDEN:CORE-CONDITION">CORE-CONDITION</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all conditions related to operations on a core.

See <a href="#MAIDEN:CORE">CORE</a>
See <a href="#MAIDEN:MAIDEN-CONDITION">MAIDEN-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:MAIDEN-CONDITION"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MAIDEN:MAIDEN-CONDITION">MAIDEN-CONDITION</a></code></h4>  </header> <div class="docstring"><pre>Superclass for all condition types in the Maiden system.</pre></div> </article> </li><li> <a name="MAIDEN:ADVICE"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:ADVICE">ADVICE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the advice information on the event or event-class.

See <a href="NIL">EVENT-CLASS</a>
See <a href="#MAIDEN:EVENT">EVENT</a></pre></div> </article> </li><li> <a name="MAIDEN:BLOCK-LOOP"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:BLOCK-LOOP">BLOCK-LOOP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the blocking back loop of the Maiden core.

This should govern one-time handlers and response events.

See <a href="#MAIDEN:CORE">CORE</a></pre></div> </article> </li><li> <a name="MAIDEN:CONSUMERS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:CONSUMERS">CONSUMERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the list of consumers associated with the core.

See <a href="#MAIDEN:CONSUMER">CONSUMER</a>
See <a href="#MAIDEN:CORE">CORE</a></pre></div> </article> </li><li> <a name="MAIDEN:CORES"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:CORES">CORES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the list of cores the consumer is currently registered with.

See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:DATA"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DATA">DATA</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the data storage container for the data entity.

See <a href="#MAIDEN:DATA-ENTITY">DATA-ENTITY</a>
See <a href="#MAIDEN:DATA-VALUE">DATA-VALUE</a></pre></div> </article> </li><li> <a name="MAIDEN:DATA-VALUE"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DATA-VALUE">DATA-VALUE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">FIELD ENTITY</code><code>)</code>  </header> <div class="docstring"><pre>Accessor for a single data field in the data entity.

See <a href="#MAIDEN:DATA">DATA</a>
See <a href="#MAIDEN:DATA-ENTITY">DATA-ENTITY</a></pre></div> </article> </li><li> <a name="MAIDEN:DIRECT-HANDLERS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DIRECT-HANDLERS">DIRECT-HANDLERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the list of direct handler definitions on the consumer class.

This only holds handler definitions that have been defined for
this specific class directly.
Also note that the handler objects contained in this list are
only abstract-handler instances and cannot be directly used as
handlers.

When this place is set, the consumer-class' inheritance is
finalized.

See <a href="#MAIDEN:CONSUMER-CLASS">CONSUMER-CLASS</a>
See <a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a>
See <a href="http://l1sp.org/mop/finalize-inheritance">MOP:FINALIZE-INHERITANCE</a></pre></div> </article> </li><li> <a name="MAIDEN:EFFECTIVE-HANDLERS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:EFFECTIVE-HANDLERS">EFFECTIVE-HANDLERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the list of effective handler definitions on the consumer class.

This holds all handler definitions, including inherited ones.
Note that the handler objects contained in this list are only
abstract-handler instances and cannot be directly used as
handlers.

When this place is set, the list of INSTANCES is updated and
each existing instance is reinitialised through REINITIALIZE-
HANDLERS.

See <a href="#MAIDEN:CONSUMER-CLASS">CONSUMER-CLASS</a>
See <a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a>
See <a href="#MAIDEN:INSTANCES">INSTANCES</a>
See <a href="NIL">REINITIALIZE-HANDLERS</a></pre></div> </article> </li><li> <a name="MAIDEN:HANDLERS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:HANDLERS">HANDLERS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>An EQL hash-table of the registered handlers on the event-loop.
Be careful when modifying this table, as it is not synchronised.

See <a href="NIL">EVENT-LOOP-LOCK</a></pre></div> </article> </li><li> <a name="MAIDEN:ID"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:ID">ID</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the IDentity of an entity.

By default this is initialised to a fresh UUIDv4 string.

See <a href="#MAIDEN:ENTITY">ENTITY</a></pre></div> </article> </li><li> <a name="MAIDEN:INSTANCES"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:INSTANCES">INSTANCES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the list of weak-pointers to consumer instances.

The elements in the list are instances of TG:WEAK-POINTER and
may point to instances of the consumer class. This list is
necessary to keep track of and properly synchronise the handlers
upon redefinition.

This list is updated whenever a new CONSUMER instance is created
or when EFFECTIVE-HANDLERS of its class is set.

See <a href="NIL">TG:WEAK-POINTER</a>
See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:LOCK"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:LOCK">LOCK</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the lock that is used to synchronise access to this object.

See <a href="#MAIDEN:CONSUMER">CONSUMER</a></pre></div> </article> </li><li> <a name="MAIDEN:NAME"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:NAME">NAME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Aecessor to the name of the entity.

See <a href="#MAIDEN:NAMED-ENTITY">NAMED-ENTITY</a></pre></div> </article> </li><li> <a name="MAIDEN:OPTIONS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:OPTIONS">OPTIONS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the list of initargs that the handler should receive upon instantiation.

See <a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:PRIMARY-LOOP"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:PRIMARY-LOOP">PRIMARY-LOOP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the primary loop of the Maiden core.

This should take care of the bulk of handlers and events.

See <a href="#MAIDEN:CORE">CORE</a></pre></div> </article> </li><li> <a name="MAIDEN:RESPONSE-EVENT"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:RESPONSE-EVENT">RESPONSE-EVENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the response event the handler captures.</pre></div> </article> </li><li> <a name="MAIDEN:TARGET-CLASS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:TARGET-CLASS">TARGET-CLASS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the target class that the actual handler should be of when the abstract-handler is instantiated.

Defaults to DEEDS:QUEUED-HANDLER

See <a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a>
See <a href="NIL">DEEDS:QUEUED-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:ADD-TO-CORE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:ADD-TO-CORE">ADD-TO-CORE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CORE &amp;REST CONSUMERS</code><code>)</code>  </header> <div class="docstring"><pre>Easily add consumers to a core.

The consumers will be started after having been added to
the core. Each consumer in the list of consumers can be:

- A symbol denoting the class of consumer to construct
- A string or keyword denoting a package that homes a
  symbol denoting a consumer class.
- A list starting with one of the above followed by the
  initargs for the class instantiation.

The instances are all constructed before any of them are
added to the core or started, so as to catch errors early.</pre></div> </article> </li><li> <a name="MAIDEN:BROADCAST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:BROADCAST">BROADCAST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CORES EVENT-TYPE &amp;REST INITARGS</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand function to construct and issue an event onto a set of cores.

Unlike DO-ISSUE, this is a function, so the event-type
has to be quoted.</pre></div> </article> </li><li> <a name="MAIDEN:ENLIST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:ENLIST">ENLIST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING &amp;REST EXTRA-ELEMENTS</code><code>)</code>  </header> <div class="docstring"><pre>If THING is a list, it is returned. Otherwise a new list out of the given elements is constructed.</pre></div> </article> </li><li> <a name="MAIDEN:FIND-CONSUMER-IN-PACKAGE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:FIND-CONSUMER-IN-PACKAGE">FIND-CONSUMER-IN-PACKAGE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">PACKAGE</code><code>)</code>  </header> <div class="docstring"><pre>Scans through the symbols in the given package and attempts to find one that denotes a class that is a subclass of CONSUMER.

The first such symbol found is returned.</pre></div> </article> </li><li> <a name="MAIDEN:FORMAT-ABSOLUTE-TIME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:FORMAT-ABSOLUTE-TIME">FORMAT-ABSOLUTE-TIME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TIME</code><code>)</code>  </header> <div class="docstring"><pre>Formats the universal-time as a timestring in the format of YYYY.MM.DD hh:mm:ss</pre></div> </article> </li><li> <a name="MAIDEN:FORMAT-RELATIVE-TIME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:FORMAT-RELATIVE-TIME">FORMAT-RELATIVE-TIME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">SECONDS</code><code>)</code>  </header> <div class="docstring"><pre>Formats the time in seconds as a human-readable string.

Time is split up into seconds, minutes, hours, days, weeks, months,
years, decades, centuries, and Ã¦ons.</pre></div> </article> </li><li> <a name="MAIDEN:FORMAT-TIME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:FORMAT-TIME">FORMAT-TIME</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TIME &amp;OPTIONAL (RELATIVE-TIME-THRESHOLD (* 60 60 24))</code><code>)</code>  </header> <div class="docstring"><pre>Formats the universal-time in a (hopefully) appropriate manner.

If the time differs from now by more than the RELATIVE-TIME-THRESHOLD
then the time is printed absolutely, otherwise relatively.

See <a href="#MAIDEN:FORMAT-RELATIVE-TIME">FORMAT-RELATIVE-TIME</a>
See <a href="#MAIDEN:FORMAT-ABSOLUTE-TIME">FORMAT-ABSOLUTE-TIME</a></pre></div> </article> </li><li> <a name="MAIDEN:GET-UNIX-TIME"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:GET-UNIX-TIME">GET-UNIX-TIME</a></code></h4> <code class="qualifiers"></code> <code class="arguments"></code><code>)</code>  </header> <div class="docstring"><pre>Returns the time in seconds since the unix epoch of 1970.</pre></div> </article> </li><li> <a name="MAIDEN:KW"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:KW">KW</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME</code><code>)</code>  </header> <div class="docstring"><pre>Return the keyword corresponding to the given symbol designator.</pre></div> </article> </li><li> <a name="MAIDEN:MAKE-CORE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:MAKE-CORE">MAKE-CORE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST CONSUMERS</code><code>)</code>  </header> <div class="docstring"><pre>Construct a new core instance and add consumers to it.

The resulting core will be started.

See <a href="#MAIDEN:CORE">CORE</a>
See <a href="#MAIDEN:ADD-TO-CORE">ADD-TO-CORE</a></pre></div> </article> </li><li> <a name="MAIDEN:MAYBE-INVOKE-DEBUGGER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:MAYBE-INVOKE-DEBUGGER">MAYBE-INVOKE-DEBUGGER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION &amp;OPTIONAL RESTART &amp;REST VALUES</code><code>)</code>  </header> <div class="docstring"><pre>Might invoke the debugger with the condition.

If *DEBUGGER* is non-NIL, the debugger is invoked with
a CONTINUE restart surrounding it to allow giving up on
handling the condition. Otherwise, if the RESTART
argument is passed, that restart is invoked with the
rest of the arguments as values for the restart.

See <a href="#MAIDEN:*DEBUGGER*">*DEBUGGER*</a></pre></div> </article> </li><li> <a name="MAIDEN:REMOVE-FUNCTION-HANDLER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:REMOVE-FUNCTION-HANDLER">REMOVE-FUNCTION-HANDLER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONSUMER NAME &amp;OPTIONAL (EVENT-TYPE NAME)</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand function to remove a function-handler definition.

This removes both the event class and the handler it defined.

See <a href="http://l1sp.org/cl/find-class">CL:FIND-CLASS</a>
See <a href="#MAIDEN:REMOVE-HANDLER">REMOVE-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:REMOVE-HANDLER"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:REMOVE-HANDLER">REMOVE-HANDLER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">ABSTRACT-HANDLER CLASS-ISH</code><code>)</code>  </header> <div class="docstring"><pre>Removes the handler from the consumer-class.

This function simply updates the list of direct-handlers
on the class by removing the corresponding abstract-handler.

The class-ish can be a CONSUMER-CLASS, a CONSUMER, or a
SYMBOL naming a consumer-class.

The abstract-handler can be an ABSTRACT-HANDLER, or a
SYMBOL denoting the NAME of an abstract-handler.

See <a href="#MAIDEN:DIRECT-HANDLERS">DIRECT-HANDLERS</a>
See <a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a>
See <a href="#MAIDEN:CONSUMER-CLASS">CONSUMER-CLASS</a></pre></div> </article> </li><li> <a name="MAIDEN:REMOVE-INSTRUCTION"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:REMOVE-INSTRUCTION">REMOVE-INSTRUCTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONSUMER INSTRUCTION &amp;OPTIONAL (EVENT-TYPE INSTRUCTION)</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand function to remove an instruction definition.

This removes both the event class, the handler, and the issue-
function it defined.

See <a href="http://l1sp.org/cl/fmakunbound">CL:FMAKUNBOUND</a>
See <a href="#MAIDEN:REMOVE-FUNCTION-HANDLER">REMOVE-FUNCTION-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:REMOVE-QUERY"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:REMOVE-QUERY">REMOVE-QUERY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONSUMER INSTRUCTION &amp;OPTIONAL (EVENT-TYPE INSTRUCTION) EVENT-RESPONSE-TYPE</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand function to remove a query definition.

This removes both the event classes, the handler, and the issue-
function it defined.

See <a href="#MAIDEN:REMOVE-FUNCTION-HANDLER">REMOVE-FUNCTION-HANDLER</a>
See <a href="http://l1sp.org/cl/find-class">CL:FIND-CLASS</a>
See <a href="http://l1sp.org/cl/fmakunbound">CL:FMAKUNBOUND</a></pre></div> </article> </li><li> <a name="MAIDEN:STARTS-WITH"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:STARTS-WITH">STARTS-WITH</a></code></h4> <code class="qualifiers"></code> <code class="arguments">START SEQUENCE &amp;KEY (TEST (FUNCTION EQL))</code><code>)</code>  </header> <div class="docstring"><pre>Returns true if SEQUENCE begins with START.</pre></div> </article> </li><li> <a name="MAIDEN:UNIVERSAL-TO-UNIX"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:UNIVERSAL-TO-UNIX">UNIVERSAL-TO-UNIX</a></code></h4> <code class="qualifiers"></code> <code class="arguments">UNIVERSAL</code><code>)</code>  </header> <div class="docstring"><pre>Convert universal-time to unix-time.</pre></div> </article> </li><li> <a name="MAIDEN:UNIX-TO-UNIVERSAL"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:UNIX-TO-UNIVERSAL">UNIX-TO-UNIVERSAL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">UNIX</code><code>)</code>  </header> <div class="docstring"><pre>Convert unix-time to universal-time.</pre></div> </article> </li><li> <a name="MAIDEN:UNLIST"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:UNLIST">UNLIST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING &amp;KEY (KEY (FUNCTION FIRST))</code><code>)</code>  </header> <div class="docstring"><pre>If THING is not a list, it is returned. Otherwise the element by KEY from the list is returned.</pre></div> </article> </li><li> <a name="MAIDEN:XNOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:XNOR">XNOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">A B</code><code>)</code>  </header> <div class="docstring"><pre>If both A and B are either true or false at the same time.</pre></div> </article> </li><li> <a name="MAIDEN:XOR"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:XOR">XOR</a></code></h4> <code class="qualifiers"></code> <code class="arguments">A B</code><code>)</code>  </header> <div class="docstring"><pre>If either A or B are true, but not both.</pre></div> </article> </li><li> <a name="MAIDEN:ADD-CONSUMER"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:ADD-CONSUMER">ADD-CONSUMER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONSUMER TARGET</code><code>)</code>  </header> <div class="docstring"><pre>Add the consumer to the core.

If the consumer already exists on the core, nothing is done.
If a consumer of the same name already exists on the core, a
warning of type CONSUMER-NAME-DUPLICATED-WARNING is signalled.

If a consumer has been added, an event of type CONSUMER-ADDED
is issued onto the core.

See <a href="#MAIDEN:CONSUMER-NAME-DUPLICATED-WARNING">CONSUMER-NAME-DUPLICATED-WARNING</a>
See <a href="#MAIDEN:CONSUMER-ADDED">CONSUMER-ADDED</a></pre></div> </article> </li><li> <a name="MAIDEN:AGENT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:AGENT">AGENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the agent that this object holds.

See <a href="#MAIDEN:AGENT-CONDITION">AGENT-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:CANCEL"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:CANCEL">CANCEL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">EVENT</code><code>)</code>  </header> <div class="docstring"><pre>Cancels the event.

An event can be cancelled multiple times though the effect does not change.
Once an event has been cancelled it can only be handled by handlers that
have HANDLE-CANCELLED set to a non-NIL value.

See <a href="NIL">CANCELLED</a>
See <a href="NIL">HANDLE-CANCELLED</a></pre></div> </article> </li><li> <a name="MAIDEN:CLIENT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:CLIENT">CLIENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the client that this object holds.

See <a href="#MAIDEN:CLIENT-CONDITION">CLIENT-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:CONSUMER"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:CONSUMER">CONSUMER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">ID TARGET</code><code>)</code>  </header> <div class="docstring"><pre>Retrieve a consumer from the core.

If no consumer that matches the ID is found, NIL is returned.

See <a href="#MAIDEN:MATCHES">MATCHES</a></pre></div> </article> </li><li> <a name="MAIDEN:CORE"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:CORE">CORE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><pre>Accessor to the core that this object holds.

See <a href="#MAIDEN:CORE-CONDITION">CORE-CONDITION</a></pre></div> </article> </li><li> <a name="MAIDEN:EXISTING-AGENT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:EXISTING-AGENT">EXISTING-AGENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><pre>Reader for the agent that already exists on the core.

See <a href="#MAIDEN:AGENT-ALREADY-EXISTS-ERROR">AGENT-ALREADY-EXISTS-ERROR</a></pre></div> </article> </li><li> <a name="MAIDEN:EXISTING-CONSUMER"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:EXISTING-CONSUMER">EXISTING-CONSUMER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><pre>Reader for the consumer that previously already existed on the core.

See <a href="#MAIDEN:CONSUMER-NAME-DUPLICATED-WARNING">CONSUMER-NAME-DUPLICATED-WARNING</a></pre></div> </article> </li><li> <a name="MAIDEN:INSTANTIATE-HANDLER"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:INSTANTIATE-HANDLER">INSTANTIATE-HANDLER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">HANDLER CONSUMER</code><code>)</code>  </header> <div class="docstring"><pre>This function creates an actual handler instance from the abstract handler definition.

The instantiation proceeds as follows:
1. The options :FILTER, :DELIVERY-FUNCTION, and :MATCH-CONSUMER
   are extracted from the options list.
2. If :MATCH-CONSUMER is given and is eql to T, then the :FILTER
   option is extended by surrounding it as follows:
     (and (eq ,consumer consumer) ..)
   where ,consumer denotes the consumer instance passed to
   instantiate-handler.
3. If :MATCH-CONSUMER is given and is not eql to T, then the :FILTER
   option is extended by surrounding it as follows:
     (and (eq ,consumer ,match-consumer) ..)
   where ,consumer is as above and ,match-consumer is the value of
   the :MATCH-CONSUMER option.
4. MAKE-INSTANCE is called with the TARGET-CLASS of the abstract
   handler, a :delivery-function initarg that is a function that
   calls the :DELIVERY-FUNCTION extracted from the option with the
   consumer and the event, a :filter initarg that is the value of
   the :FILTER option, and the rest of the OPTIONS of the abstract
   handler.

See <a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:ISSUE"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:ISSUE">ISSUE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">EVENT EVENT-DELIVERY</code><code>)</code>  </header> <div class="docstring"><pre>Issue an event to the delivery so that it is sent out to the handlers.

The exact point in time when the issued event is handled and processed
is not specified. However, the order in which events are handled must
be the same as the order in which they are issued. An event should only
ever be issued once. There is no check made to ensure this, but issuing
an event multiple times or on multiple deliveries leads to undefined
behaviour.</pre></div> </article> </li><li> <a name="MAIDEN:MATCHES"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:MATCHES">MATCHES</a></code></h4> <code class="qualifiers"></code> <code class="arguments">A B</code><code>)</code>  </header> <div class="docstring"><pre>Generic comparator operator.

This compares in a potentially ambiguous &quot;dwim&quot; sense.
Various components in the system add methods to make the
matching work as much as expected as possible.</pre></div> </article> </li><li> <a name="MAIDEN:NEW-CONSUMER"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:NEW-CONSUMER">NEW-CONSUMER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONDITION</code><code>)</code>  </header> <div class="docstring"><pre>Reader for the new consumer that is being added to the core.

See <a href="#MAIDEN:CONSUMER-NAME-DUPLICATED-WARNING">CONSUMER-NAME-DUPLICATED-WARNING</a></pre></div> </article> </li><li> <a name="MAIDEN:REMOVE-CONSUMER"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:REMOVE-CONSUMER">REMOVE-CONSUMER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CONSUMER TARGET</code><code>)</code>  </header> <div class="docstring"><pre>Remove the consumer from the core.

If the consumer doesn't exist on the core, nothing is done.
Otherwise the consumer is removed from the core's list.

If a consumer has been removed, an event of type CONSUMER-
REMOVED is issued onto the core.

See <a href="#MAIDEN:CONSUMER-REMOVED">CONSUMER-REMOVED</a></pre></div> </article> </li><li> <a name="MAIDEN:RESPOND"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:RESPOND">RESPOND</a></code></h4> <code class="qualifiers"></code> <code class="arguments">EVENT &amp;REST ARGS &amp;KEY CLASS PAYLOAD &amp;ALLOW-OTHER-KEYS</code><code>)</code>  </header> <div class="docstring"><pre>Respond to the event in an appropriate way.

The response event will be issued on to the same core that
the event being responded to was issued to. If the event
does not have a specific response event already (through a
specialised method on RESPOND), then you may specify the
class to use with the :CLASS initarg.</pre></div> </article> </li><li> <a name="MAIDEN:RUNNING"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:RUNNING">RUNNING</a></code></h4> <code class="qualifiers"></code> <code class="arguments">STUFF</code><code>)</code>  </header> <div class="docstring"><pre>Returns T if the event delivery is able to process events. </pre></div> </article> </li><li> <a name="MAIDEN:START"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:START">START</a></code></h4> <code class="qualifiers"></code> <code class="arguments">EVENT-DELIVERY</code><code>)</code>  </header> <div class="docstring"><pre>Start the event delivery and make it ready to accept and deliver events.

If the delivery is already running this does nothing.</pre></div> </article> </li><li> <a name="MAIDEN:STOP"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:STOP">STOP</a></code></h4> <code class="qualifiers"></code> <code class="arguments">EVENT-DELIVERY</code><code>)</code>  </header> <div class="docstring"><pre>Stop the event delivery to prevent it from accepting and delivering events.

If the delivery is already stopped this does nothing.</pre></div> </article> </li><li> <a name="MAIDEN:DEFINE-CONSUMER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DEFINE-CONSUMER">DEFINE-CONSUMER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME DIRECT-SUPERCLASSES DIRECT-SLOTS &amp;REST OPTIONS</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand to define a consumer class.

This is like CL:DEFCLASS, with the appropriate superclass and
metaclass injected for you. It also makes sure that the class
definition is available during compile-time as well.

See <a href="#MAIDEN:CONSUMER">CONSUMER</a>
See <a href="#MAIDEN:CONSUMER-CLASS">CONSUMER-CLASS</a></pre></div> </article> </li><li> <a name="MAIDEN:DEFINE-EVENT"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DEFINE-EVENT">DEFINE-EVENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME DIRECT-SUPERCLASSES DIRECT-SLOTS &amp;REST OPTIONS</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand macro to define an event class.

This takes care of potentially injecting the EVENT superclass
and setting the necessary EVENT-CLASS metaclass. Otherwise it
is identical to CL:DEFCLASS.

See <a href="http://l1sp.org/cl/defclass">CL:DEFCLASS</a>
See <a href="#MAIDEN:EVENT">EVENT</a>
See <a href="NIL">EVENT-CLASS</a></pre></div> </article> </li><li> <a name="MAIDEN:DEFINE-FUNCTION-HANDLER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DEFINE-FUNCTION-HANDLER">DEFINE-FUNCTION-HANDLER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(CONSUMER NAME &amp;OPTIONAL (EVENT-TYPE)) ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand macro to define an event an a corresponding handler in one go.

Special body options are extracted to provide further control over
the definition of the event:
  :SUPERCLASSES  The superclass list to use.
  :EXTRA-SLOTS   A list of extra slot definitions.
  :CLASS-OPTIONS A list of extra class options.
  :DOCUMENTATION The docstring to use for the class.
  :ADVICE        The advice value to use for the event.
Note that these options will NOT be passed on to the DEFINE-HANDLER
form.

The ARGS are used both for the arguments to DEFINE-HANDLER and as
slot definitions by way of SLOT-ARGS-&gt;SLOTS.

See <a href="NIL">SLOT-ARGS-&gt;SLOTS</a>
See <a href="#MAIDEN:DEFINE-EVENT">DEFINE-EVENT</a>
See <a href="#MAIDEN:DEFINE-HANDLER">DEFINE-HANDLER</a>
See <a href="#MAIDEN:REMOVE-FUNCTION-HANDLER">REMOVE-FUNCTION-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:DEFINE-HANDLER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DEFINE-HANDLER">DEFINE-HANDLER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(CONSUMER NAME EVENT-TYPE) ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Defines a new handler on the consumer class.

CONSUMER    must be the class-name of the consumer to define on.
NAME        must be a symbol denoting the name of the handler
            definition. Note that this name will not be carried over
            to actual handler instances, as they would otherwise
            clash on multiple consumer instances on the same core.
EVENT-TYPE  must be a base class for all events that the handler
            will receive.
ARGS        must be a list of arguments, of which the first two will
            be bound to the consumer instance and the event
            respectively. The rest of the arguments denote fuzzy slot
            bindings of the event.
BODY        a number of extra handler definition options as a plist
            followed directly by a number of forms to evaluate upon
            receiving an event.

The body options are evaluated and passed as class initargs to the
resulting handler instance once one is constructed. Note that as such
the values will be shared across all instances of the handler defined
here. Also note that there are two options which are exempt from
this and play special roles:

  :DELIVERY-FUNCTION This option is already provided by default.
                     Supplying it manually will mean that the body
                     forms of the DEFINE-HANDLER will be ignored.
  :MATCH-CONSUMER    Should be a slot name of the event that needs
                     to match the consumer for the event to be handled.
                     You'll want to use this option for handlers of
                     clients, in order to ensure that the handler from
                     the client instance that matches the client the
                     event is intended for is called.

In effect this constructs an appropriate ABSTRACT-HANDLER instance
and calls UPDATE-HANDLER with it on the consumer class.

See <a href="NIL">DEEDS:WITH-FUZZY-SLOT-BINDINGS</a>
See <a href="NIL">DEEDS:WITH-ORIGIN</a>
See <a href="#MAIDEN:ABSTRACT-HANDLER">ABSTRACT-HANDLER</a>
See <a href="NIL">UPDATE-HANDLER</a>
See <a href="#MAIDEN:REMOVE-HANDLER">REMOVE-HANDLER</a></pre></div> </article> </li><li> <a name="MAIDEN:DEFINE-INSTRUCTION"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DEFINE-INSTRUCTION">DEFINE-INSTRUCTION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(CONSUMER INSTRUCTION &amp;OPTIONAL (EVENT-TYPE)) ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand macro to define an instruction-like event.

This is essentially the same as DEFINE-FUNCTION-HANDLER with
the following additions:
- INSTRUCTION-EVENT is always injected as a superclass.
- A function of the same name as the instruction is generated that
  creates the appropriate event and sends it off to a core.

This thus allows you to simulate a standard function interface
for code that runs over the event-loop. Note that the generated
function will not wait for a response to the event and immediately
returns. The returned value is the generated event instance.

See <a href="#MAIDEN:DEFINE-FUNCTION-HANDLER">DEFINE-FUNCTION-HANDLER</a>
See <a href="#MAIDEN:BROADCAST">BROADCAST</a>
See <a href="#MAIDEN:REMOVE-INSTRUCTION">REMOVE-INSTRUCTION</a></pre></div> </article> </li><li> <a name="MAIDEN:DEFINE-QUERY"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DEFINE-QUERY">DEFINE-QUERY</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(CONSUMER INSTRUCTION &amp;OPTIONAL (EVENT-TYPE) EVENT-RESPONSE-TYPE) ARGS &amp;BODY
 BODY</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand macro to define a query-like event.

This is similar to DEFINE-INSTRUCTION, with the exception that
possibly two events (one for issue and one for response) are
generated, and that the issue function will await a response
and return with the intended return value, thus simulating a
complete function API over the event system.

If no explicit EVENT-RESPONSE-TYPE is specified, a generic
response event is used instead. See RESPOND.

See <a href="#MAIDEN:RESPOND">RESPOND</a>
See <a href="#MAIDEN:REMOVE-QUERY">REMOVE-QUERY</a></pre></div> </article> </li><li> <a name="MAIDEN:DO-ISSUE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:DO-ISSUE">DO-ISSUE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">CORE EVENT-TYPE &amp;REST INITARGS</code><code>)</code>  </header> <div class="docstring"><pre>Shorthand macro to construct and issue an event onto a core.

The event-type should not be quoted.

See <a href="#MAIDEN:DO-ISSUE">DEEDS:DO-ISSUE</a></pre></div> </article> </li><li> <a name="MAIDEN:NAMED-LAMBDA"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:NAMED-LAMBDA">NAMED-LAMBDA</a></code></h4> <code class="qualifiers"></code> <code class="arguments">NAME ARGS &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Attempt to construct a lambda with a name.

Note that standard name clashing rules apply and naming the lambda
after a CL function will likely fail if the implementation supports
package locks.</pre></div> </article> </li><li> <a name="MAIDEN:UPDATE-LIST"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:UPDATE-LIST">UPDATE-LIST</a></code></h4> <code class="qualifiers"></code> <code class="arguments">THING LIST &amp;KEY (KEY '(FUNCTION IDENTITY)) (TEST '(FUNCTION EQL))</code><code>)</code>  </header> <div class="docstring"><pre>Macro to update the list with a new item.

The item is added to the list if it is not yet contained
and updated in-place otherwise.

See <a href="NIL">MAKE-UPDATED-LIST</a></pre></div> </article> </li><li> <a name="MAIDEN:WITH-AWAITING"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:WITH-AWAITING">WITH-AWAITING</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(CORE EVENT-TYPE) ARGS SETUP-FORM &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Waits for a response event to arrive on the core before evaluating the body.

This is useful to write event-driven, reactionary code.
The temporary handler to catch the code is added to the
core's back loop.

Note that CORE can be one of
- CORE              The temporary handler is attached to
                    the core's block-loop.
- CONSUMER          The first core on the client's list of
                    cores is used as above.
- DEEDS:EVENT-LOOP  The temporary handler is directly
                    attached to it.

You can also specify a maximum waiting timeout with the
:TIMEOUT body options. The timeout is in seconds. Similar
to DEFINE-HANDLER, you can also specify a :FILTER test
body option.

See <a href="#MAIDEN:WITH-AWAITING">DEEDS:WITH-AWAITING</a></pre></div> </article> </li><li> <a name="MAIDEN:WITH-DEFAULT-ENCODING"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:WITH-DEFAULT-ENCODING">WITH-DEFAULT-ENCODING</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(&amp;OPTIONAL (ENCODING :UTF-8)) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Evaluate BODY in an environment where the default external format is set to the given encoding.

Only works on:
- SBCL
- CCL</pre></div> </article> </li><li> <a name="MAIDEN:WITH-RETRY-RESTART"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MAIDEN:WITH-RETRY-RESTART">WITH-RETRY-RESTART</a></code></h4> <code class="qualifiers"></code> <code class="arguments">(RESTART FORMAT-STRING &amp;REST FORMAT-ARGS) &amp;BODY BODY</code><code>)</code>  </header> <div class="docstring"><pre>Evaluates body around which a restart is established that allows retrying the evaluation of the body.

Similar to CL:WITH-SIMPLE-RESTART.</pre></div> </article> </li></ul> </li><li class="package"> <h3> <a name="MAIDEN-USER" href="#MAIDEN-USER">MAIDEN-USER</a> <span class="nicknames">(ORG.SHIRAKUMO.MAIDEN.USER)</span> </h3> <ul/> </li></ul> </article>  </main> </body> </html> 